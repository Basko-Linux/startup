#!/bin/sh
#
# $Id$
# /etc/rc.d/rc.sysinit - run once at boot time
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
#

# Use a safe umask.
#umask 077

# Don't do coredumps.
ulimit -Sc 0 >/dev/null 2>&1

trap '' SIGPIPE

# Rerun ourselves through initlog
if [ -z "$IN_INITLOG" -a -x /sbin/initlog ]; then
	exec /sbin/initlog $INITLOG_ARGS -r /etc/rc.d/rc.sysinit
fi

WITHOUT_RC_COMPAT=1

# Source function library.
. /etc/init.d/functions

# Fix console loglevel
dmesg -n "$LOGLEVEL"

HOSTNAME=`/bin/hostname`

# Read in config data.
if ! SourceIfNotEmpty /etc/sysconfig/network; then
	NETWORKING=no
fi

if [ -z "$HOSTNAME" -o "$HOSTNAME" = "(none)" ]; then
	HOSTNAME=localhost
fi

# Set system font.
/sbin/setsysfont >/dev/null 2>&1 && SETSYSFONT_DONE=1 || SETSYSFONT_DONE=

PrintMargin()
{
	if [ "$BOOTUP" != serial ]; then
		local n=`echo -n "$*" |wc -c`
		tput hpa $(( (COLUMNS - n)/2 ))
	fi
}

# Print a banner. ;)
WELCOME="Welcome to "
BANNER="ALT Linux"
PrintMargin "$WELCOME$BANNER"
echo -n "$WELCOME"
SETCOLOR_INFO
echo -n "$BANNER"
SETCOLOR_NORMAL
echo

if is_yes "$PROMPT"; then
	PROMPT=1
	MESSAGE="Press 'I' to enter interactive startup"
	PrintMargin "$MESSAGE"
	echo "$MESSAGE"
else
	PROMPT=
fi

# Mount /proc (done here so volume labels can work with fsck)
action "Mounting proc filesystem" mount -n -t proc /proc /proc
chgrp proc /proc >/dev/null 2>&1 ||:

# Set the system clock.
/etc/init.d/clock start

# Activate swapping.
action "Activating swap partitions:" swapon -a

# Set the hostname.
action "Setting hostname $HOSTNAME:" hostname "$HOSTNAME"

# Set the NIS domain name.
if [ -n "$NISDOMAIN" ] && ! is_no "$NISDOMAIN"; then
	action "Setting NIS domain name $NISDOMAIN:" domainname "$NISDOMAIN"
fi

if [ -f /fastboot ] || fgrep -iwqs fastboot /proc/cmdline; then
	fastboot=yes
else
	fastboot=
fi

if [ -n "$FSCKOPTIONS" ]; then
	fsckoptions="$FSCKOPTIONS"
else
	fsckoptions=
fi

if [ -f /forcefsck ]; then
	fsckoptions="-f $fsckoptions"
fi

if [ "$BOOTUP" != "serial" ]; then
	fsckoptions="-C $fsckoptions"
else
	fsckoptions="-V $fsckoptions"
fi

# LVM Setting
VGCHANGE=/sbin/vgchange
if [ -x "$VGCHANGE" -a -s /etc/lvmtab ]; then
	modprobe lvm-mod >/dev/null 2>&1
	if [ -e /proc/lvm ]; then
		action "Setting up LVM:" "$VGCHANGE" -a y
	fi
fi

_RUN_QUOTACHECK=0
ROOTFSTYPE=`fgrep ' / ' /proc/mounts |tail -1 |cut -d' ' -f3`
if [ -z "$fastboot" -a "$ROOTFSTYPE" != nfs ]; then 
	STRING="Checking root filesystem"
	echo "$STRING"
	initlog -c "fsck -Tay $fsckoptions /"
	rc=$?

	# The exit code returned by fsck is the sum of the following conditions:
	#     0    - No errors
	#     1    - File system errors corrected
	#     2    - System should be rebooted
	#     4    - File system errors left uncorrected
	#     8    - Operational error
	#     16   - Usage or syntax error
	#     32   - Fsck canceled by user request
	#     128  - Shared library error

	if [ $rc = 0 ]; then
		success "$STRING"
		echo
	elif [ $rc = 1 ]; then
		passed "$STRING"
		echo
	else
		failure "$STRING"
		echo
	fi

	if [ $rc -gt 1 ]; then
		# A return of 3 or higher means there were serious problems.
		if [ $rc -gt 3 ]; then
			echo
			echo "*** An error occurred during the file system check."
			echo "*** Dropping you to a shell; the system will reboot"
			echo "*** when you leave the shell."

			PS1="(Repair filesystem) \# # "; export PS1
			sulogin
		fi

		echo "Remounting root filesystem readonly."
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ $rc = 1 ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# check for arguments 

if fgrep -iqs nopnp /proc/cmdline; then
	PNP=
else
	PNP=yes
fi

# set up pnp 
if [ -x /sbin/isapnp -a -s /etc/isapnp.conf ]; then
	if [ -n "$PNP" ]; then
		action "Setting up ISA PNP devices:" /sbin/isapnp /etc/isapnp.conf
	else
		action "Skipping ISA PNP configuration at users request:" /bin/true
	fi
fi

# Remount the root filesystem read-write.
action "Remounting root filesystem in read/write mode:" mount -n -o remount,rw /

# Clear mtab
[ -L /etc/mtab ] ||  >/etc/mtab

# Remove stale backups
rm -f /etc/mtab~ /etc/mtab~~

# Enter root and /proc into mtab. (pixel) also added /initrd/loopfs for loopback root
mount -f /initrd/loopfs 2>/dev/null
mount -f /
mount -f /proc
[ -f /proc/bus/usb/devices ] && mount -f -t usbdevfs usbdevfs /proc/bus/usb
[ -e /dev/.devfsd ] && mount -f -t devfs devfs /dev 

# Settin hard disk parameters
/etc/rc.d/scripts/idetune

# Update quotas if fsck was run on /.
QUOTACHECK=/sbin/quotacheck
if [ "$_RUN_QUOTACHECK" = 1 -a -x "$QUOTACHECK" ]; then
	action "Checking root filesystem quotas:" "$QUOTACHECK" -v /
fi

# The root filesystem is now read-write, so we can now log via syslog() directly.
[ -z "$IN_INITLOG" ] || IN_INITLOG=

echo "$HOSTNAME" >/etc/HOSTNAME

if [ -f /proc/ksyms ] && ! fgrep -iwqs nomodules /proc/cmdline; then
	USEMODULES=y
else
	USEMODULES=
fi

# Our modutils don't support it anymore, so we might as well remove
# the preferred link.
rm -f /lib/modules/{preferred,default}
if [ -x /sbin/depmod -a -n "$USEMODULES" ]; then
	# If they aren't using a recent sane kernel, make a link for them
	if [ ! -n "`uname -r |fgrep -- -`" ]; then
		ktag="`cat /proc/version`"
		mtag=`fgrep -l -- "$ktag" /lib/modules/*/.rhkmvtag 2>/dev/null`
		if [ -n "$mtag" ]; then
			mver=`echo $mtag |sed -e 's,/lib/modules/,,' -e 's,/.rhkmvtag,,' -e 's,[ 	].*$,,'`
		fi
		if [ -n "$mver" ]; then
			ln -snf "/lib/modules/$mver" /lib/modules/default
		fi
	fi
	if [ -L /lib/modules/default ]; then
		INITLOG_ARGS= action "Finding module dependencies:" depmod -A default
	else
		INITLOG_ARGS= action "Finding module dependencies:" depmod -A
	fi
fi

# Configure kernel parameters
action "Configuring kernel parameters:" sysctl -e -p /etc/sysctl.conf

if [ -f /proc/sys/kernel/modprobe ]; then
	if [ -n "$USEMODULES" ]; then
		sysctl -w kernel.modprobe="/sbin/modprobe" >/dev/null 2>&1
		sysctl -w kernel.hotplug="/sbin/hotplug" >/dev/null 2>&1
	else
		# We used to set this to NULL, but that causes 'failed to exec' messages"
		sysctl -w kernel.modprobe="/bin/true" >/dev/null 2>&1
		sysctl -w kernel.hotplug="/bin/true" >/dev/null 2>&1
	fi
fi

OLD_COLUMNS="$COLUMNS"

# Load modules
/etc/rc.d/scripts/load_modules

# Load framebuffer device settings
/etc/rc.d/scripts/framebuffer_init

# Set system font again, if required.
if [ "$OLD_COLUMNS" != "$COLUMNS" ]; then
	/sbin/setsysfont >/dev/null 2>&1 && SETSYSFONT_DONE=1 || SETSYSFONT_DONE=
fi

# Add raid devices
if [ -f /proc/mdstat -a -s /etc/raidtab ]; then
	echo -n "Starting up RAID devices: " 

	rc=0
	
	for i in `grep -s "^raiddev" /etc/raidtab | awk '{print $2}'`; do
		RAIDDEV="${i##*/}"
		RAIDSTAT=`grep -s "^$RAIDDEV : active" /proc/mdstat`
		if [ -z "$RAIDSTAT" ]; then
			# Try raidstart first...if that fails then
			# fall back to raidadd, raidrun.  If that
			# also fails, then we drop to a shell
			RESULT=1
			ExecIfExecutable /sbin/raidstart "$i"
			RESULT=$?
			if [ $RESULT -gt 0 ]; then
				ExecIfExecutable /sbin/raid0run "$i"
				RESULT=$?
			fi
			if [ $RESULT -gt 0 ]; then
				ExecIfExecutable /sbin/raidadd "$i"
				ExecIfExecutable /sbin/raidrun "$i"
				RESULT=$?
			fi
			if [ $RESULT -gt 0 ]; then
				rc=1
			fi
		fi
		echo -n "$RAIDDEV "
	done
	echo

	# A non-zero return means there were problems.
	if [ $rc -gt 0 ]; then
		echo
		echo
		echo "*** An error occurred during the RAID startup"
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(RAID Repair) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -arnf
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	fi
fi

_RUN_QUOTACHECK=0
# Check filesystems
# (pixel) do not check loopback files, will be done later (aren't available yet)
if [ -z "$fastboot" ]; then
	STRING="Checking filesystems"
	echo "$STRING"
	initlog -c "fsck -TRAay -t noloop $fsckoptions"
	rc=$?

	if [ $rc = 0 ]; then
		success "$STRING"
		echo
	elif [ $rc = 1 ]; then
		passed "$STRING"
		echo
	else
		failure "$STRING"
		echo
	fi

	if [ $rc -gt 1 ]; then
		# A return of 3 or higher means there were serious problems.
		if [ $rc -gt 3 ]; then
			echo
			echo "*** An error occurred during the file system check."
			echo "*** Dropping you to a shell; the system will reboot"
			echo "*** when you leave the shell."

			PS1="(Repair filesystem) \# # "; export PS1
			sulogin
		fi

		echo "Unmounting file systems."
		umount -arnf
		echo "Remounting root filesystem readonly."
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ $rc = 1 ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
# (pixel) also do not mount loopback, will be done later
action "Mounting local filesystems:" mount -a -t nonfs,smbfs,ncpfs,proc,loop

# (pixel) Check loopback filesystems
if [ -z "$fastboot" ]; then
	STRING="Checking loopback filesystems:"
	echo -n "$STRING "
	initlog -c "fsck -TRAay -t loop,ext2 $fsckoptions"
	rc=$?
	if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
		passed "$STRING"
		echo
	fi

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \#"; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -arnf
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ "$rc" = "1" -a -x "$QUOTACHECK" ]; then
		action "Checking filesystem quotas:" "$QUOTACHECK" -v -R -a
	fi
fi

# Mount loopback
action "Mounting loopback filesystems:" mount -a -t loop,ext2,vfat

# At this point everything should be mounted.

# Set system font again, if required.
[ -n "$SETSYSFONT_DONE" ] || /sbin/setsysfont >/dev/null 2>&1

# Initialize screensaver
if [ -x /usr/bin/setterm -a -d /usr/share/terminfo -a -s /etc/sysconfig/console/setterm ]; then
	action "Initializing console powersaver:" \
		"sh -c \"/usr/bin/setterm `cat /etc/sysconfig/console/setterm` >/dev/console\""
fi

# Try to get linuxconf profile.
if profile=$(sed 's/.*prof=\([A-Za-z_0-9]*\).*$/\1/' /proc/cmdline) && \
	[ -d "/etc/linuxconf/archive/$profile" -o -d "/etc/linuxconf/archive/$profile-family" ] && \
	! fgrep -qs "confver.current $profile" /etc/conf.linuxconf; then

	action "Setting profile to $profile:" /bin/linuxconf --selectprofile "$profile"
	
	# Setting again network scripts.
	if SourceIfNotEmpty /etc/sysconfig/network; then
		hostname "$HOSTNAME"
		echo "$HOSTNAME" >/etc/HOSTNAME
	fi
fi

if [ "$_RUN_QUOTACHECK" = 1 -a -x "$QUOTACHECK" ]; then
	action "Checking filesystem quotas:" "$QUOTACHECK" -v -R -a
fi

if [ -x /sbin/quotaon ]; then
	action "Turning on user and group quotas for local filesystems:" /sbin/quotaon -a
fi

# Do the following while waiting for an 'I' from the user...
{

# Cleanup everything :)
action "Cleaning up temporary files from previous boot:" /etc/rc.d/scripts/cleanup

# Language fixes
/etc/rc.d/scripts/lang

# Now turn on swap again (in case we swap to files).
swapon -a >/dev/null 2>&1
action "Enabling swap space:" /bin/true

# Initialize the serial ports.
ExecIfExecutable /etc/rc.d/rc.serial

# Initialize firewall.
for f in /etc/rc.d/scripts/firewall /etc/rc.d/rc.firewall /etc/rc.firewall; do
	if ExecIfExecutable "$f"; then
		break
	fi
done

# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -f /proc/scsi/scsi ] && fgrep -qs 'Type:   Sequential-Access' /proc/scsi/scsi; then
	if fgrep -qv ' 9 st' /proc/devices ; then
		if [ -n "$USEMODULES" ] ; then
			# Try to load the module.  If it fails, ignore it...
			insmod -p st >/dev/null 2>&1 && modprobe st >/dev/null 2>&1
		fi
	fi
fi

# If they asked for ide-scsi, load it
if fgrep -iwqs ide-scsi /proc/cmdline; then
	modprobe ide-cd >/dev/null 2>&1
	modprobe ide-scsi >/dev/null 2>&1
fi

# Adjust symlinks as necessary in /boot to keep system services from
# spewing messages about mismatched System maps and so on.
if [ -L /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	ln -snf System.map-`uname -r` /boot/System.map 2>/dev/null
fi
if [ ! -e /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	ln -snf System.map-`uname -r` /boot/System.map 2>/dev/null
fi

if [ -x /usr/sbin/update_wms ]; then
	action "Updating Window Manager Sessions:" /usr/sbin/update_wms
fi

# Autogenerate kernel headers.
ExecIfExecutable /etc/rc.d/scripts/gen_kernel_headers ||
ExecIfExecutable /etc/init.d/kheader

# Check if /mnt/cdrom, /mnt/floppy and /mnt/disk are here - if not create them
[ -d /mnt/cdrom ] || action "Creating /mnt/cdrom:" mkdir -p /mnt/cdrom
[ -d /mnt/floppy ] || action "Creating /mnt/floppy:" mkdir -p /mnt/floppy
[ -d /mnt/disk ] || action "Creating /mnt/disk:" mkdir -p /mnt/disk

# Update alternatives for VLAN configuration program.
ExecIfExecutable /etc/rc.d/scripts/vconfig-update

if [ -x /usr/sbin/update_chrooted ]; then
	action "Updating chrooted environments:" /usr/sbin/update_chrooted conf lib
fi

# Tune RSBAC if required.
ExecIfExecutable /etc/rc.d/scripts/rsbac_autotune

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
dmesg >/var/log/dmesg
kill -TERM `/sbin/pidof getkey` >/dev/null 2>&1

} &

if [ -n "$PROMPT" ]; then
	/sbin/getkey i || PROMPT=
fi
wait

if [ -n "$PROMPT" ]; then
	touch /var/run/confirm
fi
