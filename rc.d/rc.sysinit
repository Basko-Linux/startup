#!/bin/sh
#
# /etc/rc.d/rc.sysinit - run once at boot time
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
#

trap '' SIGPIPE

# Rerun ourselves through initlog
if [ -z "$IN_INITLOG" ]; then
	[ -f /sbin/initlog ] && exec /sbin/initlog $INITLOG_ARGS -r /etc/rc.d/rc.sysinit
fi

# Source functions
. /etc/init.d/functions

HOSTNAME=`/bin/hostname`

# Read in config data.
if ! SourceIfNotEmpty /etc/sysconfig/network; then
	NETWORKING=no
fi

if [ -z "$HOSTNAME" -o "$HOSTNAME" = "(none)" ]; then
	HOSTNAME=localhost
fi

# Print a banner. ;)
if [ "$BOOTUP" != "serial" ]; then
	echo -e '\t\t\tWelcome to Linux \e[1;36mMandrake \e[1;32mRE\e[0;39m'
else
	echo -e '\t\t\tWelcome to Linux Mandrake RE'
fi
if [ -n "$PROMPT" -a "$PROMPT" != 'no' ]; then
	PROMPT=1
	echo -e "\t\tPress 'I' to enter interactive startup."
else
	PROMPT=
fi

# Mount /proc (done here so volume labels can work with fsck)
action "Mounting proc filesystem" mount -n -t proc /proc /proc
chgrp proc /proc &>/dev/null ||:

# Configure kernel parameters
action "Configuring kernel parameters:" sysctl -p /etc/sysctl.conf

# Try to get devfsd
if [ -c /dev/.devfsd -a -x /sbin/devfsd ]; then
	if action "Running DevFS daemon:" devfsd /dev; then
		for i in /dev/cdroms/*; do 
			ln -sf "$i" /dev/
		done
		if [ -e /dev/cdrom0	]; then
			ln -sf /dev/cdrom0 /dev/cdrom
		fi
		if SourceIfNotEmpty /etc/sysconfig/mouse; then
			device=`echo "$device" |sed -e 's,psaux,misc/psaux,' -e 's/ttyS\(.\)/tts\/\1/g'`
			if [ -n "$device" ]; then
				ln -s "/dev/$device" /dev/mouse
			fi
		fi
	fi
fi

# Fix console loglevel
dmesg -n "$LOGLEVEL"

# Set the system clock.
/etc/init.d/clock start

# Activate swapping.
action "Activating swap partitions:" swapon -a

# Set the hostname.
action "Setting hostname $HOSTNAME:" hostname "$HOSTNAME"

if [ -f /fastboot ] || fgrep -iwqs fastboot /proc/cmdline; then
	fastboot=yes
else
	fastboot=
fi

if [ -f /fsckoptions ]; then
	fsckoptions=`cat /fsckoptions`
else
	fsckoptions=
fi

if [ -f /forcefsck ]; then
	fsckoptions="-f $fsckoptions"
fi

if [ "$BOOTUP" != "serial" ]; then
	fsckoptions="-C $fsckoptions"
else
	fsckoptions="-V $fsckoptions"
fi

# LVM Setting
VGCHANGE=/sbin/vgchange
if [ -e /proc/lvm -a -x "$VGCHANGE" ]; then
	"$VGCHANGE" -a y
fi

_RUN_QUOTACHECK=0
ROOTFSTYPE=`fgrep ' / ' /proc/mounts |cut -d' ' -f3`
if [ -z "$fastboot" -a "$ROOTFSTYPE" != "nfs" ]; then 
	STRING="Checking root filesystem"
	echo "$STRING"
	initlog -c "fsck -Tay $fsckoptions /"
	rc=$?
	
	if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
		passed "$STRING"
		echo
	fi
	
	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ "$rc" = "1" ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# check for arguments 

if fgrep -iqs nopnp /proc/cmdline; then
	PNP=
else
	PNP=yes
fi

# set up pnp 
if [ -x /sbin/isapnp -a -s /etc/isapnp.conf ]; then
	if [ -n "$PNP" ]; then
		action "Setting up ISA PNP devices:" /sbin/isapnp /etc/isapnp.conf
	else
		action "Skipping ISA PNP configuration at users request:" /bin/true
	fi
fi

# Remount the root filesystem read-write.
action "Remounting root filesystem in read/write mode:" mount -n -o remount,rw /

# Clear mtab
>/etc/mtab

# Remove stale backups
rm -f /etc/mtab~ /etc/mtab~~

# Enter root and /proc into mtab. (pixel) also added /initrd/loopfs for loopback root
mount -f /initrd/loopfs 2>/dev/null
mount -f /
mount -f /proc

# Settin hard disk parameters
/etc/rc.d/scripts/idetune

# Update quotas if fsck was run on /.
QUOTACHECK=/sbin/quotacheck
if [ "$_RUN_QUOTACHECK" = 1 -a -x "$QUOTACHECK" ]; then
	action "Checking root filesystem quotas:" "$QUOTACHECK" -v /
fi

# The root filesystem is now read-write, so we can now log via syslog() directly..
if [ -n "$IN_INITLOG" ]; then
	IN_INITLOG=
fi

echo "$HOSTNAME" >/etc/HOSTNAME

if [ -f /proc/ksyms ] && ! fgrep -iwqs nomodules /proc/cmdline; then
	USEMODULES=y
else
	USEMODULES=
fi

# Our modutils don't support it anymore, so we might as well remove
# the preferred link.
rm -f /lib/modules/{preferred,default}
if [ -x /sbin/depmod -a -n "$USEMODULES" ]; then
	# If they aren't using a recent sane kernel, make a link for them
	if [ ! -n "`uname -r |fgrep -- -`" ]; then
		ktag="`cat /proc/version`"
		mtag=`fgrep -l -- "$ktag" /lib/modules/*/.rhkmvtag 2>/dev/null`
		if [ -n "$mtag" ]; then
			mver=`echo $mtag |sed -e 's,/lib/modules/,,' -e 's,/.rhkmvtag,,' -e 's,[ 	].*$,,'`
		fi
		if [ -n "$mver" ]; then
			ln -snf "/lib/modules/$mver" /lib/modules/default
		fi
	fi
	if [ -L /lib/modules/default ]; then
		INITLOG_ARGS= action "Finding module dependencies:" depmod -A default
	else
		INITLOG_ARGS= action "Finding module dependencies:" depmod -A
	fi
fi

if [ -f /proc/sys/kernel/modprobe ]; then
	if [ -n "$USEMODULES" ]; then
		sysctl -w kernel.modprobe="/sbin/modprobe" &>/dev/null
	else
		# We used to set this to NULL, but that causes 'failed to exec' messages"
		sysctl -w kernel.modprobe="/bin/true" &>/dev/null
	fi
fi

# Load modules
/etc/rc.d/scripts/load_modules

# Add raid devices
if [ -f /proc/mdstat -a -s /etc/raidtab ]; then
	echo -n "Starting up RAID devices: " 

	rc=0
	
	for i in `grep "^raiddev" /etc/raidtab | awk '{print $2}'`; do
		RAIDDEV="${i##*/}"
		RAIDSTAT=`grep "^$RAIDDEV : active" /proc/mdstat`
		if [ -z "$RAIDSTAT" ]; then
			# Try raidstart first...if that fails then
			# fall back to raidadd, raidrun.  If that
			# also fails, then we drop to a shell
			RESULT=1
			ExecIfExecutable /sbin/raidstart "$i"
			RESULT=$?
			if [ $RESULT -gt 0 ]; then
				ExecIfExecutable /sbin/raid0run "$i"
				RESULT=$?
			fi
			if [ $RESULT -gt 0 ]; then
				ExecIfExecutable /sbin/raidadd "$i"
				ExecIfExecutable /sbin/raidrun "$i"
				RESULT=$?
			fi
			if [ $RESULT -gt 0 ]; then
				rc=1
			fi
		fi
		echo -n "$RAIDDEV "
	done
	echo

	# A non-zero return means there were problems.
	if [ $rc -gt 0 ]; then
		echo
		echo
		echo "*** An error occurred during the RAID startup"
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(RAID Repair) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -arnf
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	fi
fi

_RUN_QUOTACHECK=0
# Check filesystems
# (pixel) do not check loopback files, will be done later (aren't available yet)
if [ -z "$fastboot" ]; then
	STRING="Checking filesystems"
	echo "$STRING"
	initlog -c "fsck -TRAay -t noloop $fsckoptions"
	rc=$?
	if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
		passed "$STRING"
		echo
	fi

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -arnf
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ "$rc" = "1" -a -x "$QUOTACHECK" ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
# (pixel) also do not mount loopback, will be done later
action "Mounting local filesystems:" mount -a -t nonfs,smbfs,ncpfs,proc,loop

# (pixel) Check loopback filesystems
if [ -z "$fastboot" ]; then
	STRING="Checking loopback filesystems:"
	echo -n "$STRING "
	initlog -c "fsck -TRAay -t loop,ext2 $fsckoptions"
	rc=$?
	if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
		passed "$STRING"
		echo
	fi

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \#"; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -arnf
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ "$rc" = "1" -a -x "$QUOTACHECK" ]; then
		action "Checking filesystem quotas:" "$QUOTACHECK" -v -R -a
	fi
fi

# Mount loopback
action "Mounting loopback filesystems:" mount -a -t loop,ext2,vfat

# At this point everything should be mounted.

# Load keymap and system font, setup powersaver
. /etc/rc.d/scripts/console

# Try to get linuxconf profile.
if profile=$(sed 's/.*prof=\([A-Za-z_0-9]*\).*$/\1/' /proc/cmdline) && \
	[ -d "/etc/linuxconf/archive/$profile" -o -d "/etc/linuxconf/archive/$profile-family" ] && \
	! fgrep -qs "confver.current $profile" /etc/conf.linuxconf; then

	action "Setting profile to $profile:" /bin/linuxconf --selectprofile "$profile"
	
	# Setting again network scripts.
	if SourceIfNotEmpty /etc/sysconfig/network; then
		hostname "$HOSTNAME"
		echo "$HOSTNAME" >/etc/HOSTNAME
	fi
fi

if [ X"$_RUN_QUOTACHECK" = X1 -a -x "$QUOTACHECK" ]; then
	action "Checking filesystem quotas:" "$QUOTACHECK" -v -R -a
fi

# Configure machine if necessary.
if [ -f /.unconfigured ]; then
	ExecIfExecutable /usr/bin/passwd root
	ExecIfExecutable /usr/sbin/netconfig
	ExecIfExecutable /usr/sbin/timeconfig
	ExecIfExecutable /usr/sbin/authconfig --nostart
	ExecIfExecutable /usr/sbin/ntsysv --level 35

	# Reread in network configuration data.
	if SourceIfNotEmpty /etc/sysconfig/network ]; then
		# Reset the hostname.
		action "Resetting hostname $HOSTNAME:" hostname "$HOSTNAME"
	fi

	rm -f /.unconfigured
fi

if [ -x /sbin/quotaon ]; then
	action "Turning on user and group quotas for local filesystems:" /sbin/quotaon -a
fi

# Do the following while waiting for an 'I' from the user...
{

# Cleanup everything :)
action "Cleaning up temporary files from previous boot:" /etc/rc.d/scripts/cleanup

# Language fixes
/etc/rc.d/scripts/lang

# Now turn on swap again (in case we swap to files).
swapon -a &>/dev/null
action "Enabling swap space:" /bin/true

# Initialize the serial ports.
ExecIfExecutable /etc/rc.d/rc.serial

# Initialize firewall.
for f in /etc/rc.d/scripts/firewall /etc/rc.d/rc.firewall /etc/rc.firewall; do
	if ExecIfExecutable "$f"; then
		break
	fi
done

# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -f /proc/scsi/scsi ] && fgrep -qs 'Type:   Sequential-Access' /proc/scsi/scsi; then
	if fgrep -qv ' 9 st' /proc/devices ; then
		if [ -n "$USEMODULES" ] ; then
			# Try to load the module.  If it fails, ignore it...
			insmod -p st &>/dev/null && modprobe st &>/dev/null
		fi
	fi
fi

# Adjust symlinks as necessary in /boot to keep system services from
# spewing messages about mismatched System maps and so on.
if [ -L /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	ln -snf System.map-`uname -r` /boot/System.map 2>/dev/null
fi
if [ ! -e /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	ln -snf System.map-`uname -r` /boot/System.map 2>/dev/null
fi

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
dmesg >/var/log/dmesg
kill -TERM `/sbin/pidof getkey` &>/dev/null

} &

if [ -n "$PROMPT" ]; then
	/sbin/getkey i || PROMPT=
fi
wait

if [ -n "$PROMPT" ]; then
	touch /var/run/confirm
fi

if fgrep -iwqs "failsafe" /proc/cmdline; then
	touch /var/run/failsafe
fi

if [ -x /etc/rc.d/scripts/mandrake_everytime ]; then 
	/etc/rc.d/scripts/mandrake_everytime
fi
