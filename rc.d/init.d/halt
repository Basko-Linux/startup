#!/bin/bash
#
# rc.halt       This file is executed by init when it goes into runlevel
#               0 (halt) or runlevel 6 (reboot). It kills all processes,
#               unmounts file systems and then either halts or reboots.
#
# Author:       Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
#               Modified for RHS Linux by Damien Neil
#

. /etc/init.d/functions

runcmd() {
   echo -n "$1 "
   shift
   if [ "$BOOTUP" = "color" ]; then
      $* && echo_success || echo_failure
   else
      $*
   fi
   echo
}

# See how we were called.
case "$0" in
  *halt)
	message="The system is halted"
	command="halt"
	;;
  *reboot)
	message="Please stand by while rebooting the system..."
	command="reboot"
	;;
  *)
	echo "$0: call me as \"rc.halt\" or \"rc.reboot\" please!"
	exit 1
	;;
esac

# Kill all processes.
[ "${BASH+bash}" = bash ] && enable kill

runcmd "Sending all processes the TERM signal..." /sbin/killall5 -15
sleep 5
runcmd "Sending all processes the KILL signal..."  /sbin/killall5 -9

# Write to wtmp file before unmounting /var
halt -w

# Sync clock
/etc/init.d/clock stop

# Turn off swap, then unmount file systems.
SWAPS=`awk '! /^Filename/ { print $1 }' /proc/swaps`
[ -n "$SWAPS" ] && runcmd "Turning off swap: " swapoff $SWAPS

QUOTAOFF=/sbin/quotaoff
[ -x "$QUOTAOFF" ] && runcmd "Turning off quotas: " "$QUOTAOFF" -a

ACCTOFF=/sbin/accton
[ -x "$ACCTOFF" ] && runcmd "Turning off accounting: " "$ACCTOFF"

# first remove entry /initrd/loopfs as it can't be unmounted :(
mtab=$(grep -v "/initrd/loopfs[^/]" /etc/mtab)
(IFS= ; echo $mtab >/etc/mtab)

# Unmount file systems, killing processes if we have to.
sig=
retry=3
remaining=`awk '!/(^#|proc|loopfs|^none|^\/dev\/root| \/ )/ {print $2}' /proc/mounts`
while [ -n "$remaining" -a "$retry" -gt 0 ]
do
	if [ "$retry" -lt 3 ]; then
		runcmd "Unmounting file systems (retry): "  umount -a -f -t noproc
	else
		runcmd "Unmounting file systems: "  umount -a -f -t noproc
	fi
	sleep 2
	remaining=`awk '!/(^#|proc|loopfs|^none|^\/dev\/root| \/ )/ {print $2}' /proc/mounts`
	[ -z "$remaining" ] && break
	/sbin/fuser -k -m $sig $remaining >/dev/null
	sleep 5
	retry=$(($retry-1))
	sig=-9
done

# turn off raid
if [ -x /sbin/raidstop -a -f /etc/raidtab ]; then
    # we can not use raidstop -a here because this will only stop
    # devices listed in the default config file which is not always
    # the case. So we look only for the active raid devices
    if [ -f /proc/mdstat ] ; then
	mddevs=$(grep ^md /proc/mdstat | awk '{ print $1 }')
	for mddev in $mddevs ; do
	    runcmd "Turning off RAID for $mddev: " raidstop /dev/$mddev
	done
        unset mddev mddevs
    fi
    #runcmd "Turning off RAID: " /sbin/raidstop -a
fi

# Remount read only anything that's left mounted.
#echo "Remounting remaining filesystems (if any) readonly"
umount -arnf
mount -n -o remount,ro /

runcmd "Unmounting proc file system: " umount /proc

# See if this is a powerfail situation.
UPSCTL=/etc/apcupsd/apccontrol
if [ -x "$UPSCTL" -a -f /etc/powerfail ]; then
  echo "APCUPSD will now power off the UPS!"
  echo
  "$UPSCTL" killpower
  echo
  echo "Please ensure that the UPS has powered off before rebooting"
  echo "Otherwise, the UPS may cut the power during the reboot!!!"
  echo
  sleep 120
  exit 1
fi

# Now halt or reboot.
echo "$message"
if [ -f /fastboot ]; then
	echo "On the next boot fsck will be skipped."
elif [ -f /forcefsck ]; then
	echo "On the next boot fsck will be forced."
fi

HALTARGS="-i -d -p"
if [ -f /halt ]; then
	HALTARGS="-i -d"
fi

eval $command $HALTARGS
