#!/bin/bash
#
# $Id$
#
# rc.halt       This file is executed by init when it goes into runlevel
#               0 (halt) or runlevel 6 (reboot). It kills all processes,
#               unmounts file systems and then either halts or reboots.
#
# Author:       Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
#               Modified for RHS Linux by Damien Neil
#

# Set the path.
PATH=/sbin:/bin:/usr/bin:/usr/sbin
export NOLOCALE=1
. /etc/init.d/functions
unset TEXTDOMAIN TEXTDOMAINDIR

unset action
action()
{
	echo -n "$1 "
	shift
	if [ "$BOOTUP" = "color" ]; then
		$* && echo_success || echo_failure
	else
		$*
	fi
	local rc=$?
	echo -e '\r'
	return $rc
}

# See how we were called.
case "$0" in
	*halt)
		message="The system is halted"
		command=/sbin/halt
		;;
	*reboot)
		message="Please stand by while rebooting the system..."
		command=/sbin/reboot
		;;
	*poweroff)
		message="The system is turned off"
		command=/sbin/poweroff
		;;
	*)
		echo "${0##*/}: call me as \"rc.halt\", \"rc.reboot\" or \"rc.poweroff\" please!"
		exit 1
		;;
esac

if [ -n "$1" ]; then
	case "$1" in
		*start)
			;;
		*)
			echo "Usage: (halt|reboot) {start}"
			exit 1
			;;
	esac
fi

# Kill all processes.
[ "${BASH+bash}" = bash ] && enable kill

action "Sending all processes the TERM signal..." /sbin/killall5 -15

if [ -f /proc/progress ]; then
	echo 45 > /proc/progress
fi

sleep 5
action "Sending all processes the KILL signal..."  /sbin/killall5 -9

if [ -f /proc/progress ]; then
	echo 40 > /proc/progress
fi

# Write to wtmp file before unmounting /var
halt -w

# Sync clock
/etc/init.d/clock stop

if [ -f /proc/progress ]; then
	echo 35 > /proc/progress
fi

# Turn off swap, then unmount file systems.
SWAPS=`awk '! /^Filename/ { print $1 }' /proc/swaps`
[ -n "$SWAPS" ] && action "Turning off swap:" swapoff $SWAPS

if [ -f /proc/progress ]; then
	echo 30 > /proc/progress
fi

QUOTAOFF=/sbin/quotaoff
[ -x "$QUOTAOFF" ] && action "Turning off quotas:" "$QUOTAOFF" -a

if [ -f /proc/progress ]; then
	echo 25 > /proc/progress
fi

ACCTOFF=/sbin/accton
[ -x "$ACCTOFF" ] && action "Turning off accounting:" "$ACCTOFF"

if [ -f /proc/progress ]; then
	echo 20 > /proc/progress
fi

# Unmount supermount and autofs*.
UnmountFilesystems 3 5 \
	'$2 != "/" && (($3 == "supermount") || ($3 == "autofs") || ($3 == "autofs4")) {print $2}' \
	"Unmounting automount filesystem" \
	"Unmounting automount filesystem (retry)"

# Unmount loopback stuff first.
UnmountFilesystems 3 5 \
	'$2 != "/" && $1 ~ /^\/dev\/loop/ {print $2}' \
	"Unmounting loopback filesystem" \
	"Unmounting loopback filesystem (retry)"

if [ -f /proc/progress ]; then
	echo 15 > /proc/progress
fi

# Unmount all the rest.
UnmountFilesystems 3 5 \
	'$2 != "/" && $3 != "proc" && $3 != "devfs" && $3 != "loopfs" && !($1 ~ /^none/) {print $2}' \
	"Unmounting filesystem" \
	"Unmounting filesystem (retry)"

if [ -f /proc/progress ]; then
	echo 10 > /proc/progress
fi

# Turn off raid.
RAIDSTOP=/sbin/raidstop
if [ -x "$RAIDSTOP" -a -f /etc/raidtab ]; then
	# we can not use raidstop -a here because this will only stop
	# devices listed in the default config file which is not always
	# the case. So we look only for the active raid devices
	if [ -f /proc/mdstat ] ; then
		mddevs=$(grep ^md /proc/mdstat | awk '{ print $1 }')
		for mddev in $mddevs ; do
			action "Turning off RAID for $mddev:" "$RAIDSTOP" "/dev/$mddev"
		done
		unset mddev mddevs
	fi
	#action "Turning off RAID:" /sbin/raidstop -a
fi

[ -f /proc/bus/usb/devices ] && umount -n /proc/bus/usb &>/dev/null

# Remount read only anything that's left mounted.
action "Remounting remaining filesystems (if any) readonly:" umount -anrf
mount -n -o remount,ro /

if [ -f /proc/progress ]; then
    echo 0 > /proc/progress
fi

action "Unmounting proc filesystem:" umount -n /proc

# See if this is a powerfail situation.
UPSCTL=/etc/apcupsd/apccontrol
if [ -x "$UPSCTL" -a -f /etc/apcupsd/powerfail ]; then
	action "Attempting to turn the UPS off:" "$UPSCTL" killpower
	message="The system is turned off"
	command=/sbin/poweroff
fi

if [ -f /poweroff ] || [ "$command" = /sbin/halt -a ! -f /halt ]; then
	message="The system is turned off"
	command=/sbin/poweroff
fi

if [ "$command" = /sbin/poweroff ]; then
	# Modprobe apm for automatic poweroff at ATX cases.
	/sbin/modprobe apm &>/dev/null
fi

if [ -f /fastboot ]; then
	echo "On the next boot fsck will be skipped."
elif [ -f /forcefsck ]; then
	echo "On the next boot fsck will be forced."
fi

# Now halt or reboot.
echo "$message"
$command -i -d
