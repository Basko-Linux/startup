#!/bin/bash
#
# rc.halt       This file is executed by init when it goes into runlevel
#               0 (halt) or runlevel 6 (reboot). It kills all processes,
#               unmounts file systems and then either halts or reboots.
#
# Author:       Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
#               Modified for RHS Linux by Damien Neil
#

# Set the path.
PATH=/sbin:/bin:/usr/bin:/usr/sbin
export NOLOCALE=1
. /etc/init.d/functions
unset TEXTDOMAIN TEXTDOMAINDIR

runcmd()
{
	echo -n "$1 "
	shift
	if [ "$BOOTUP" = "color" ]; then
		$* && echo_success || echo_failure
	else
		$*
	fi
	echo
}

# See how we were called.
case "$0" in
	*halt)
		message="The system is halted"
		command="halt"
		;;
	*reboot)
		message="Please stand by while rebooting the system..."
		command="reboot"
		;;
	*)
		echo "$0: call me as \"rc.halt\" or \"rc.reboot\" please!"
		exit 1
		;;
esac

if [ -n "$1" ]; then
	case "$1" in
		*start)
			;;
		*)
			echo "Usage: (halt|reboot) {start}"
			exit 1
			;;
	esac
fi

# Kill all processes.
[ "${BASH+bash}" = bash ] && enable kill

runcmd "Sending all processes the TERM signal..." /sbin/killall5 -15
sleep 5
runcmd "Sending all processes the KILL signal..."  /sbin/killall5 -9

# Write to wtmp file before unmounting /var
halt -w

# Sync clock
/etc/init.d/clock stop

# Turn off swap, then unmount file systems.
SWAPS=`awk '! /^Filename/ { print $1 }' /proc/swaps`
[ -n "$SWAPS" ] && runcmd "Turning off swap:" swapoff $SWAPS

QUOTAOFF=/sbin/quotaoff
[ -x "$QUOTAOFF" ] && runcmd "Turning off quotas:" "$QUOTAOFF" -a

ACCTOFF=/sbin/accton
[ -x "$ACCTOFF" ] && runcmd "Turning off accounting:" "$ACCTOFF"

# Unmount file systems, killing processes if we have to.

UnmountFilesystems()
{
	local sig=
	local retry="$1"
	shift
	local delay="$1"
	shift
	local pattern="$1"
	shift
	local message1="$1"
	shift
	local message2="$1"
	shift

	local remaining=`awk "$pattern" /proc/mounts`
	while [ -n "$remaining" -a "$retry" -gt 0 ]; do
		if [ "$retry" -lt 3 ]; then
			runcmd "$message2" umount -f -t noproc $remaining
		else
			runcmd "$message1" umount -f -t noproc $remaining
		fi
		local remaining=`awk "$pattern" /proc/mounts`
		[ -n "$remaining" ] || break
		/sbin/fuser -k -m $sig $remaining >/dev/null
		sleep $delay
		retry=$[retry-1]
		sig=-9
	done
}

# Unmount loopback stuff first.
UnmountFilesystems 3 5 \
	'$1 ~ /^\/dev\/loop/ && $2 != "/" {print $2}' \
	"Unmounting loobpack filesystems:" \
	"Unmounting loopback filesystems (retry):"

# Unmount all the rest.
UnmountFilesystems 3 5 \
	'!/(proc|loopfs|autofs|^none|^\/dev\/root| \/ )/ {print $2}' \
	"Unmounting filesystems:" \
	"Unmounting filesystems (retry):"

# Turn off raid.
RAIDSTOP=/sbin/raidstop
if [ -x "$RAIDSTOP" -a -f /etc/raidtab ]; then
	# we can not use raidstop -a here because this will only stop
	# devices listed in the default config file which is not always
	# the case. So we look only for the active raid devices
	if [ -f /proc/mdstat ] ; then
		mddevs=$(grep ^md /proc/mdstat | awk '{ print $1 }')
		for mddev in $mddevs ; do
			runcmd "Turning off RAID for $mddev:" "$RAIDSTOP" "/dev/$mddev"
		done
		unset mddev mddevs
	fi
	#runcmd "Turning off RAID:" /sbin/raidstop -a
fi

[ -f /proc/bus/usb/devices ] && umount -n /proc/bus/usb &>/dev/null

# Remount read only anything that's left mounted.
runcmd "Remounting remaining filesystems (if any) readonly:" umount -anrf
mount -n -o remount,ro /

runcmd "Unmounting proc filesystem:" umount -n /proc

# See if this is a powerfail situation.
UPSCTL=/etc/apcupsd/apccontrol
if [ -x "$UPSCTL" -a -f /etc/powerfail ]; then
	echo "APCUPSD will now power off the UPS!"
	echo
	"$UPSCTL" killpower
	echo
	echo "Please ensure that the UPS has powered off before rebooting"
	echo "Otherwise, the UPS may cut the power during the reboot!!!"
	echo
	sleep 120
	exit 1
fi

# Now halt or reboot.
echo "$message"
if [ -f /fastboot ]; then
	echo "On the next boot fsck will be skipped."
elif [ -f /forcefsck ]; then
	echo "On the next boot fsck will be forced."
fi

HALTARGS="-i -d"
if [ -f /poweroff -o ! -f /halt ]; then
	HALTARGS="$HALTARGS -p"
fi

eval $command $HALTARGS
