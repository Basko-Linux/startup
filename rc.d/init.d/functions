#!/bin/sh
#
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#
# Version:	@(#) /etc/init.d/functions 1.01 26-Oct-1993
#
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:    Greg Galloway and Marc Ewing
#

# First set up a default search path.
export PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"

SourceIfExists()
{
	[ -f "$1" ] && . "$1"
}

SourceIfExecutable()
{
	[ -x "$1" ] && . "$1"
}

SourceIfNotEmpty()
{
	[ -s "$1" ] && . "$1"
}

ExecIfExecutable()
{
	local executable="$1"
	shift
	[ -x "$executable" ] && "$executable" "$@"
}

# Get a sane screen width
[ -n "$COLUMNS" ] || COLUMNS=80

# Read in our configuration
if [ -z "$BOOTUP" ]; then
	SourceIfNotEmpty /etc/sysconfig/init
	[ -n "$BOOTUP" ] || BOOTUP=color
fi

if [ -x /sbin/consoletype ] && [ "`consoletype`" = "serial" ]; then
	BOOTUP=serial
fi

if [ "$BOOTUP" != "color" ]; then
	MOVE_TO_COL(){ :; }
	SETCOLOR_SUCCESS(){ :; }
	SETCOLOR_FAILURE(){ :; }
	SETCOLOR_WARNING(){ :; }
	SETCOLOR_NORMAL(){ :; }
else
	# This all seem confusing? Look in /etc/sysconfig/init,
	# or in /usr/share/doc/initscripts-*/sysconfig.txt
	[ -n "$RES_OFFSET" ] && [ "$RES_OFFSET" -gt 0 ] 2>/dev/null || RES_OFFSET=8
	if [ "`type -t MOVE_TO_COL`" != "function" ]; then
		MOVE_TO_COL(){ echo -en "\033[$[COLUMNS-RES_OFFSET]G"; }
	fi
	if [ "`type -t SETCOLOR_SUCCESS`" != 'function' ]; then
		SETCOLOR_SUCCESS(){ echo -en '\033[1;32m'; }
	fi
	if [ "`type -t SETCOLOR_FAILURE`" != 'function' ]; then
		SETCOLOR_FAILURE(){ echo -en '\033[1;31m'; }
	fi
	if [ "`type -t SETCOLOR_WARNING`" != 'function' ]; then
		SETCOLOR_WARNING(){ echo -en '\033[1;33m'; }
	fi
	if [ "`type -t SETCOLOR_NORMAL`" != 'function' ]; then
		SETCOLOR_NORMAL(){ echo -en '\033[0;39m'; }
	fi
fi

if [ "$BOOTUP" != "verbose" ]; then
   INITLOG_ARGS="-q"
else
   INITLOG_ARGS=
fi

[ -n "$LOGLEVEL" ] && [ "$LOGLEVEL" -ge 0 ] 2>/dev/null || LOGLEVEL=1

# Check if $pid (could be plural) are running
checkpid() {
	while [ "$1" ]; do
		[ -d "/proc/$1" ] && return 0 || shift
	done
	return 1
}

# A function to start a program.
daemon() {
	# Test syntax.
	gotbase=
	user=
	nicelevel=0
	while [ "$1" != "${1##-}" -o "$1" != "${1##+}" ]; do 
	  case $1 in
	    '')    echo '$0: Usage: daemon [+/-nicelevel] {program}'
	           return 1;;
	    --check)
	           shift
		   base=$1
		   gotbase="yes"
		   shift
		   ;;
	    --user)
	    	   shift
		   daemon_user=$1
		   shift
		   ;;
	    -*|+*) nicelevel=$1
	           shift
		   ;;
	     *)    nicelevel=0
	     	   ;;
	  esac
	done

	# Save basename.
	[ -n "$gotbase" ] || base="${1##*/}"

	# See if it's already running.
	pidlist=`pidofproc $1`
	
	pid=
	for apid in $pidlist; do
		if [ -d /proc/$apid ]; then
			pid="$pid $apid"
		fi
	done

	
	# Echo daemon
	if [ "$BOOTUP" = "verbose" ]; then echo -n "$base "; fi

	[ -z "$pid" ] || { echo_passed; return; }

	# make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems
	ulimit -Sc 0 &>/dev/null
	
	# And start it up.
	if [ -z "$daemon_user" ]; then 
		nice -n $nicelevel initlog $INITLOG_ARGS -c "$*" && success "$base startup" || failure "$base startup"
	else
		nice -n $nicelevel initlog $INITLOG_ARGS -c "su - $daemon_user -c \"$*\" -s /bin/sh" && success "$base startup" || failure "$base startup"
	fi
}

# usage: wait_pid <w_pid> <w_times> <w_delay>
wait_pid()
{
	local w_pid="$1"
	shift
	local w_times="$1"
	shift
	local w_delay="$1"
	shift

	local i=0
	while [ $i -lt "$w_times" ]; do
		checkpid $w_pid &>/dev/null || return 0
		usleep "$w_delay"
		i=$[1+i]
	done
	! checkpid $w_pid
}

# A function to stop a program.
killproc() {
	RC=0
	# Test syntax.
	if [ $# = 0 ]; then
		echo "Usage: killproc {program} [signal]"
		return 1
	fi

	notset=0
	# check for second arg to be kill level
	if [ -n "$2" ]; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

	# Save basename.
	base="${1##*/}"

	# Find pid.
	pidlist=`pidofproc $1`
	
	pid=
	for apid in $pidlist; do
		if [ -d "/proc/$apid" ]; then
			pid="$pid $apid"
		fi
	done

	# Kill it.
	if [ -n "$pid" ]; then
		if [ "$BOOTUP" = "verbose" ]; then echo -n "$base "; fi
		if [ "$notset" = "1" ] ; then
			if checkpid $pid 2>&1; then
				# TERM first, then KILL if not dead
				kill -TERM -- $pid
				if ! wait_pid "$pid" 30 100000; then
					kill -KILL -- $pid
					usleep 100000
				fi
			fi
			checkpid $pid &>/dev/null
			RC=$?
			[ $RC -eq 0 ] && failure "$base shutdown" || success "$base shutdown"
			RC=$((! $RC))
		# use specified level only
		else
			if checkpid $pid &>/dev/null; then
				kill "$killlevel" -- $pid
				RC=$?
				[ $RC -eq 0 ] && success "$base $killlevel" || failure "$base $killlevel"
			fi
		fi
	else
	    failure "$base shutdown"
	fi

	# Remove pid file if any.
	if [ "$notset" = "1" ]; then
		rm -f "/var/run/$base.pid"
	fi
	return $RC
}

# A function to find the pid of a program.
pidofproc() {
	base="${1##*/}"

	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: pidofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f "/var/run/$base.pid" ]; then
		pid=`cat "/var/run/$base.pid" | { read foo; echo -E "$foo"; }`
		if [ -n "$pid" -a -d "/proc/$pid" ]; then
			echo -E "$pid"
			return 0
		fi
	fi

	# Next try "pidof"
	pid=`pidof -o $$ -o $PPID -o %PPID -x "$base"`
	if [ -n "$pid" -a -d "/proc/$pid" ]; then
		echo -E "$pid"
		return 0
	fi
}

status() {
	# Test syntax.
	if [ $# = 0 ]; then
		echo "Usage: status {program}"
		return 1
	fi

	base="${1##*/}"

	# First try "pidof"
	pid=`pidof -o $$ -o $PPID -o %PPID -x "$base"`
	if [ -n "$pid" -a -d "/proc/$pid" ]; then
	        echo "$base (pid $pid) is running..."
	        return 0
	fi

	# Next try "/var/run/*.pid" files
	if [ -s "/var/run/$base.pid" ]; then
		pid=`cat "/var/run/$base.pid" | { read foo; echo -E "$foo"; }`
		if [ -n "$pid" ]; then
			echo "$base dead but pid file exists"
			return 1
		fi
	fi
	# See if /var/lock/subsys/$base exists
	if [ -f "/var/lock/subsys/$base" ]; then
		echo "$base dead but subsys locked"
		return 2
	fi
	echo "$base is stopped"
	return 3
}

echo_success() {
	MOVE_TO_COL
	echo -n '[  '
	SETCOLOR_SUCCESS
	echo -n 'OK'
	SETCOLOR_NORMAL
	echo -n '  ]'
	return 0
}

echo_failure() {
	MOVE_TO_COL
	echo -n '['
	SETCOLOR_FAILURE
	echo -n 'FAILED'
	SETCOLOR_NORMAL
	echo -n ']'
	return 1
}

echo_passed() {
	MOVE_TO_COL
	echo -n '['
	SETCOLOR_WARNING
	echo -n 'PASSED'
	SETCOLOR_NORMAL
	echo -n ']'
	return 1
}

# Log that something succeeded
success() {
	if [ -z "$IN_INITLOG" ]; then
		initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
	else
		local opipe=`trap -p SIGPIPE`
		trap '' SIGPIPE
		echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 1" >&21
		$opipe
	fi
	echo_success
	return 0
}

# Log that something failed
failure() {
	rc=$?
	if [ -z "$IN_INITLOG" ]; then
		initlog $INITLOG_ARGS -n $0 -s "$1" -e 2
	else
		local opipe=`trap -p SIGPIPE`
		trap '' SIGPIPE
		echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 2" >&21
		$opipe
	fi
	echo_failure
	return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
	rc=$?
	if [ -z "$IN_INITLOG" ]; then
		initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
	else
		local opipe=`trap -p SIGPIPE`
		trap '' SIGPIPE
		echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 1" >&21
		$opipe
	fi
	echo_passed
	return $rc
}  

# Run some action. Log its output.
action() {
	STRING=$1
	echo -n "$STRING "
	shift
	initlog $INITLOG_ARGS -c "$*" && success "$STRING" || failure "$STRING"
	rc=$?
	echo -e '\r'
	return $rc
}

# Confirm whether we really want to run this service
confirm() {
  echo -n "Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
  read answer
  case $answer in
    y|Y|"")
      return 0
    ;;
    c|C)
      return 2
    ;;
    n|N)
      return 1
    ;;
    *)
      confirm $1
      return $?
    ;;
    esac
}
